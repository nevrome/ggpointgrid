// [[Rcpp::depends(Rcpp)]]
#include <Rcpp.h>
extern "C" {
#include "arrange.h"  // generated by Futhark
}
using namespace Rcpp;

// [[Rcpp::export]]
Rcpp::List futhark_entry_arrange_from_coordinates_cpp(
    Rcpp::NumericVector grid_xs,
    Rcpp::NumericVector grid_ys,
    Rcpp::NumericVector pts_x,
    Rcpp::NumericVector pts_y
) {
  // Basic input checks (adapt as appropriate for your function)
  if (grid_xs.size() != grid_ys.size()) {
    Rcpp::stop("grid_xs and grid_ys must have the same length.");
  }
  if (pts_x.size() != pts_y.size()) {
    Rcpp::stop("pts_x and pts_y must have the same length.");
  }
  
  // Create Futhark context
  futhark_context_config* cfg = futhark_context_config_new();
  if (!cfg) Rcpp::stop("Failed to create Futhark context config.");
  futhark_context* ctx = futhark_context_new(cfg);
  if (!ctx) {
    futhark_context_config_free(cfg);
    Rcpp::stop("Failed to create Futhark context.");
  }
  
  // Wrap inputs as Futhark arrays (f64 = double)
  futhark_f64_1d* in0 = futhark_new_f64_1d(ctx, grid_xs.begin(), (int64_t)grid_xs.size());
  futhark_f64_1d* in1 = futhark_new_f64_1d(ctx, grid_ys.begin(), (int64_t)grid_ys.size());
  futhark_f64_1d* in2 = futhark_new_f64_1d(ctx, pts_x.begin(),  (int64_t)pts_x.size());
  futhark_f64_1d* in3 = futhark_new_f64_1d(ctx, pts_y.begin(),  (int64_t)pts_y.size());
  if (!in0 || !in1 || !in2 || !in3) {
    if (in0) futhark_free_f64_1d(ctx, in0);
    if (in1) futhark_free_f64_1d(ctx, in1);
    if (in2) futhark_free_f64_1d(ctx, in2);
    if (in3) futhark_free_f64_1d(ctx, in3);
    futhark_context_free(ctx);
    futhark_context_config_free(cfg);
    Rcpp::stop("Failed to create Futhark input arrays.");
  }
  
  // Outputs from Futhark
  futhark_f64_1d* out0 = nullptr;
  futhark_f64_1d* out1 = nullptr;
  
  // Call the Futhark entry point
  int rc = futhark_entry_arrange_from_coordinates(ctx, &out0, &out1, in0, in1, in2, in3);
  if (rc != 0) {
    futhark_free_f64_1d(ctx, in0);
    futhark_free_f64_1d(ctx, in1);
    futhark_free_f64_1d(ctx, in2);
    futhark_free_f64_1d(ctx, in3);
    futhark_context_free(ctx);
    futhark_context_config_free(cfg);
    Rcpp::stop("futhark_entry_arrange_from_coordinates failed with error code %d.", rc);
  }
  
  // Determine output sizes via Futhark
  const int64_t* shp0 = futhark_shape_f64_1d(ctx, out0);
  const int64_t* shp1 = futhark_shape_f64_1d(ctx, out1);
  R_xlen_t n0 = (R_xlen_t)shp0[0];
  R_xlen_t n1 = (R_xlen_t)shp1[0];
  
  // Allocate R vectors and copy results back
  Rcpp::NumericVector res0(n0);
  Rcpp::NumericVector res1(n1);
  futhark_values_f64_1d(ctx, out0, res0.begin());
  futhark_values_f64_1d(ctx, out1, res1.begin());
  
  // Make sure everything is finished
  futhark_context_sync(ctx);
  
  // Free Futhark resources
  futhark_free_f64_1d(ctx, out0);
  futhark_free_f64_1d(ctx, out1);
  futhark_free_f64_1d(ctx, in0);
  futhark_free_f64_1d(ctx, in1);
  futhark_free_f64_1d(ctx, in2);
  futhark_free_f64_1d(ctx, in3);
  futhark_context_free(ctx);
  futhark_context_config_free(cfg);
  
  // Return two numeric vectors
  return Rcpp::List::create(res0, res1);
}
